路由 配置 优先级 顺序从上到下

有插槽的组件要避免 父子组件直接嵌套，应该预留插槽给子组件,
例如 goodsList 和 goodsListItem

sass-loader 版本过高导致 部分参数undefined,报错，
需要安装低版本，
注意:一般情况下，安装插件后凡是报错显示某某参数或值不正确，
    很可能是 版本不兼容造成

发现: cnpm install all 会导致 在node_moduels 上建立索引，导致内存占用增加

关于背景图静态资源等，让后端提供url比较好

sass 缺少 python环境，需要安装

css 的 background,
background-size :
contain 会保持图片缩放比，当width较小时会repeat
cover使得图片完全适应父dom
background-repeat:no-repeat; 设置不重复使用背景图填充 ,包括x,y方向
background-attachment:fixed; 会占据在浏览器窗口初始的位置，即使dom滚动，背景也不会改变
注意： background-attachment:fixed 在占据浏览器的位置后，即使外部节点结构发生变化，导致
      位置改变，图片的固定位置也不会改变，而当dom经过图片显示区域时，背景图才会展示出来

background-position:
在background-attachment:fixed;的情况下，背景图片相对于html元素，或者说是浏览器窗口
background-position 可以调整 图片相对的位置
当background-attachment不为fixed的情况下:
scroll(默认)  当设置背景图的dom的过大需要滑动时，背景图不会跟着滑动，
相当于背景图过大，被截取了
local  当设置背景图的dom的过大需要滑动时，背景图会跟着滑动,背景图不被截取


很奇怪，p标签中不能放置其它的块级元素，若放置后会被
浏览器自动 渲染为紧接着自身 的兄弟元素

vue项目结构的views子组件只套一层！

图标 颜色风格相近，那么就有必要定制一套 样式  github，qq ， b站


在起初配置vuescroll时，注意，插件注册必须经过 Vue.use或者Vue.component

Vue.extend({}) 继承成为一个Vue对象
Vue.component('cpn',cpn)，注册组件到全局中去
components:{
    cpn 
}  注册组件到局部

某些小部件最好设置固定大小，相对于window窗口时，
窗口变化会使得组件变化过于扭曲，
方案一  calc(px + 百分比) /  calc(em + 百分比)
方案二 : mixWidth, minHeight  /  maxWidth, manHeight

关于响应式布局，除了限定 组件在某个范围内是否显示外，
还要限制在某个范围内，内容是否换行

关于网络请求，如果数据可能被其它组件使用，那么写在父组件，否则写在子组件，
在supermall中，由于后端接口中数据耦合，需要父组件分发，因而请求代码 放在了 父组件
不清楚时，建议先写在子组件

margin是可重叠的！！， 例如 A   B  其中A的margin-right可以和B的margin-left 重合

icon  ::before  content: "\e741"  这和 @font-face 有关

transform 的变形不会使得 dom本身大小发生改变
transition 要先于 属性变化开始设置，否则会无效
transition 若设置在 hover中，会使得 过渡只有一半

适当使用 h1~h6 来代替设置加大加粗字体

适当使用 window对象 来解决一些不足,如 onmousemove

window.onmouseout 和 window.onmouseleave 是不一样的！！！ 前者只局限于mousedown时的dom，后者范围为整个浏览器

某些算法要先考虑逻辑，如  (this.$refs.barBtn.offsetLeft - this.beforeX ) 若这一步执行后，不先让btn移动，
则值永远为0

user-select:none 防止btn误选文本

移动端滑动事件 和 pc 端的滑动事件是不一样的

transition enter 部分可以 理解 为 插入前演示
插入的组件 从 enter 到 enter-to 的特效，
leave 则是离开前，
对于enter，enter-to可以不是必须的，
而对于leave， v-leave 不是必需的，而leave-to是必须的

使用用 vue 的 transition

dom.getBoundRect() 获得的位置是包括transform造成的影响的!!! ，如 progress-bar-btn

如果不能确定 $refs 是否有引用，那么可以在 使用前 更新以下dom，然后使用 this.$nextTick()

number 变 String 使用 + '' ，或者toString,记得使用toFixed() 控制尾数
java中需要调用包装类的方法

不该在vue的methods中调用computed的方法,也无法调用

::before 和 ::after 伪元素无法无法直接 和 块级元素一行

实践发现: float 只适合在 大小 已经为具体的值时，布局使用，其余情况使用时 感觉过于难受

toFixed() 会导致四舍五入

如果只是希望 hover的时候，实现让组件消失或者出现的过渡，
那么尽量不使用 v-if , 使用 v-show，
或者是 配合 capacity，
v—show 出现时会重新占据空间，导致dom结构改变， 而capacity则一直占有

提高流畅度的优化:
v-if, @mouseenter,@mouseleave,Vuetransition => v-show, @mouseenter,@mouseleave,Vuetransition
                              => hover,capacity,transition
因此，涉及到有流畅度要求的组件，不能使用v-if

在base.css 里 定制响应式布局的变量,
为包装变量兼容性，使用下列格式
  color: #7F583F;
  color: var(--primary);
保证有默认值(比较麻烦)

document.body.style.setProperty('--primary', '#7F583F');
document.body.style.getPropertyValue('--primary').trim();
document.body.style.removeProperty('--primary');
或者直接设置 document.body.style.属性值 = xxx

vuex 中为 每个state 提供一个getters,
然后 映射到 computed中

vuex 用于管理全局的 用户对象

padding 和 margin 的百分比相对父dom的 宽度

直接写在组件上的class会生效,并合并到子组件去class去

由view 以及 子组件 完成页面布局，
公共组件和业务组件一般都是设置为 width100% 和 height 100% 或者 固定的width或height


hover效果，不仅可以设置opcatity变浅，还可以设置变深！！（起强调作用）

在过渡事件比较短的情况下，透明度变化区间过长，则变化过程则不太明显，像是突变，
此时应该缩短区间 如 rgba(255,255,255,0) => rgba(255,255,255,.6)

属性的过渡必须在声明了transition的统一范围下，否则会无效  --blog-box

复习: 路由有默认路径为'/',在第一层的路由，/代表刚进入网页时，默认的跳转路径，
在第二层路由，也就子组件，默认路径为'/'，代表在第一层路由下的默认子组件，
而非默认组组件，若有参数部分，则需要继续按照父路由的顺序定义路径的参数，否则会被子路由当做普通路径的一部分，而不是参数

正则表达式不需要引号！！
          let reg = /....../ 而不是  '/..../'！